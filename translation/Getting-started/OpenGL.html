<!DOCTYPE html>
<html lang="en"> 
<head>
	<meta charset="utf-8" />
	<link rel="stylesheet" href="../static/style.css" />
</head>
<body>
    <div id="content">
    <h1 id="content-title">OpenGL</h1>
<h1 id="content-url" style='display:none;'>Getting-started/OpenGL</h1>
<p>学習をはじめる前にOpenGLとは何かを確認しておきましょう。OpenGLとはグラフィックや画像を操作するための関数を多数提供するAPI（<def>アプリケーションプログラミングインターフェース</def>）だと考えられています。しかしOpenGLそのものはAPIではなく、<a href="http://www.khronos.org/" target="_blank">Khronos Group</a>により開発及びメンテナンスされている仕様です。</p>

<img src="/img/getting-started/opengl.jpg" class="right" alt="Image of OpenGL's logo"/>

<p>
OpenGLの仕様は各関数がどのようにふるまい、どのような結果を残し、あるいどんな出力を返すのかを正確に規定しています。これらの関数をどのようにして仕様どおりに機能させるかは、開発者の<em>実装</em>に任されています。OpenGLの仕様は実装についての詳細を規定していないので、得られる結果が仕様通りである（つまりユーザーから見て同じである）限り、様々な実装が可能です。
</p>

<p>
OpenGLのライブラリを開発しているのは、おもにグラフィックカードの製造者です。あなたが購入したグラフィックカードはその製品（あるいはそのシリーズ）に特化したOpenGLのバージョンをサポートしています。AppleのシステムではOpenGLのライブラリはApple自身によりメンテナンスされており、Linuxにおいてはグラフィックカードの製造者によるライブラリや、趣味の開発者によるものもあります。つまりOpenGLがおかしな挙動をする場合はたいていグラフィックカードの製造者（またはライブラリの開発に関わった誰か）のミスです。
</p>

<note>
ほとんどの実装はグラフィックカードの製造者によるものなので、バグが見付かった場合はビデオカードのドライバをアップデートすることでたいてい解決します。最新のドライバにはそのグラフィックカードがサポートする最新のOpenGLが含まれているからです。グラフィックドライバをときどきアップデートするべき理由のひとつです。
</note>

<p>
KhronosはすべてのOpenGLのバージョンの仕様に関するドキュメントを公開しています。興味がある読者はこれからみなさんが利用するバージョン3.3の仕様を<a href="https://www.opengl.org/registry/doc/glspec33.core.20100311.withchanges.pdf" target="_blank">ここ</a>で確認できます。このページはOpenGLの詳細を理解するのに非常に役立ちます（実装ではなく結果ばかりが記述されていることを確認してください）。OpenGLの仕様は関数の<strong>正確な</strong>ふるまいを確認する文献としても重要です。
</p>

<h1>unko</h1>

<h2>Core-profileとImmediate mode</h2>
<p>
古くは、OpenGLを利用するとは<def>immediate mode</def>（<def>fixed function pipeline</def>とも）で開発することでした。immediate modeはグラフィックを描写する簡単な方法です。OpenGLのほとんどの機能はライブラリのなかに隠され、開発者は演算の方法にまで深くは踏み込めませんでした。開発者は柔軟性を求めるようになり、それにともない仕様のほうも柔軟になりました。開発者がグラフィックの描画方法にに関してより多くのことを操作できるようになったのです。immediate modeは理解し使用するのは非常に簡単ですが、効率はかなり悪いです。そのため仕様はバージョン3.2からimmediate modeを廃止し<def>core-profile</def> modeを推奨しはじめました。core-profile modeでは廃止された古い機能がすべてとりのぞかれています。
</p>

<p>
core-profileを使うには新しい方法にしたがう必要があります。廃止された機能を使おうとするとOpenGLがエラーを出して描画を停止します。新しい方法の利点は柔軟性と効率のよさです。ただしその一方で習得するのが難しいです。immediate modeはOpenGLがおこなっている<strong>実際の</strong>操作の多くを抽象化しているので習得するのが簡単な一方、OpenGLが実際になにをおこなっているかを把握するのは難しいです。新しい方法ではOpenGLやグラフィックプログラミングについての理解が必要であるのですこし難解ではあるものの、柔軟性や効率のよさ、そして一番重要なことですが、グラフィックプログラミングに関するよりよい理解が得られます。
</p>

<p>
そのためこの本ではOpenGLバージョン3.3のcore-profileについて重点的に解説します。理解するのは大変ですが、努力する価値は十分にあります。
</p>

<p>
今日、OpenGLのもっと新しいバージョンが利用できます（執筆時点での最新は4.6）。にも関わらずバージョン3.3を学習する意味があるのかと疑問に思うかもしれませんが、その答えは比較的簡単です。バージョン3.3より新しいものはすべて、このバージョンに便利な機能を追加したものであり、OpenGLの核となる部分は変更されません。新しいバージョンのものは以前と同じことをするうえでより効率がいい、あるいはより使いやすい方法を導入しただけです。考えかたややりかたはバージョン3.3以降かわらないので、このバージョンを学ぶことが有効なのです。バージョン3.3でOpenGLに慣れ親しめば、より新しいバージョンの機能を利用することは簡単です。
</p>

<warning>
最新のOpenGLを使って開発したアプリケーションは、最新のグラフィックカード以外では動作しません。そのためほとんどの開発者は古いバージョンのOpenGLで開発し、新しいバージョンの機能は対応するグラフィックカードへのオプションとして組込みます。
</warning>

<p>
一部の章ではことわったうえで新しい機能を利用することがあります。
</p>

<h2>拡張機能</h2>
<p>
OpenGLの大きな特徴に、拡張機能のサポートがあります。グラフィックカードの製造者が新しい技術を導入したり、レンダリングを大幅に最適化した場合、それらの機能はドライバに実装されてる<def>拡張機能</def>によって提供されることが多いです。アプリケーションが動作しているハードウェアがそういった拡張機能をサポートしていれば、開発者はそれらを利用し先進的、あるいは効率のいい方法でグラフィックを描画することができます。このような最新の機能は、グラフィックカードによりサポートされているかを確認するだけで利用できるので、開発者はOpenGLにその機能が組込まれるのを待つ必要がありません。ある拡張機能が人気になり、あるいは便利であれば将来のOpenGLのバージョンに組込まれることになります。
</p>

<p>
上記のようなグラフィックカードに特有の（あるいはOpenGL自身の）拡張機能を利用する前に、その機能が利用可能かどうかを確かめる必要があります。こうすることで、拡張機能が利用可能かどうかに応じてより効率のよいプログラムを書くことができます:
</p>

<pre><code>
if(GL_ARB_extension_name)
{
	// 最新の機能を利用したクールなコード
}
else
{
	// 拡張機能がサポートされていない場合: 従来の方法を利用したコード
}。
</code></pre>
<p>
OpenGLバージョン3.3において拡張機能はほとんど必要ありませんが、利用する場合は解説を付けます。
</p>

<h2>状態機械</h2>
<p>
OpenGLはひとつの大きな状態機械だといえます: 各時点におけるOpenGLの動作を規定する変数の集まりだという意味です。OpenGLの状態は<def>コンテクスト</def>と呼ばれます。OpenGLでは、オプションの設定やバッファの操作により状態を変化させ、その時点のコンテクストを利用してレンダリングをおこないます。
</p>

<p>
例えば描画するものを三角形から直線に変更するためには、コンテクストの変数のうち描画する図形を規定するものを変更することでOpenGLの状態を変化させることになります。そのようにコンテクストを変更すれば、以降の描画命令では三角形ではなく直線が描かれます。
</p>
  
<p>
OpenGLでの開発において、コンテクストを変更する<def>状態遷移</def>関数や、現在の状態にもとづいてなんらかの操作をおこなう<def>状態利用</def>関数を利用することになります。OpenGLが大きな状態機械であるということを頭にいれておけば、さまざまな機能を理解するのが楽になります。
</p>

<h2>オブジェクト</h2>
<p>
OpenGLのライブラリはC言語で記述されています。ほかの言語からの利用も可能ですが、核となる部分はC言語のライブラリのままです。C言語の言語構造は他の高水準の言語にうまく翻訳できないので、OpenGLはいくつかの抽象的な概念を念頭に開発されました。<def>オブジェクト</def>の概念がそのひとつです。
</p>

<p>
OpenGLにおいて<def>オブジェクト</def>とは、OpenGLの状態をあらわしたオプションのあつまりです。たとえばウィンドウの描画にかかる設定をまとめたオブジェクトを作ることができます。このオブジェクトを通して、ウィンドウの大きさや表示できる色の数等を設定することができます。オブジェクトはC言語の構造体のようなものとしてとらえることができます:
</p>

<pre><code>
struct object_name {
    float  option1;
    int    option2;
    char[] name;
};。
</code></pre>

<p>
オブジェクトはたいてい以下のようなかたちで利用することになります（前半の部分はOpenGLのコンテクストを大きな構造体として記述したものです）:
</p>

<pre><code>
// OpenGLの状態
struct OpenGL_Context {
  	...
  	object_name* object_Window_Target;
  	...  	
};
</code></pre>
  
<pre><code>
// オブジェクトの作成
unsigned int objectId = 0;
glGenObject(1, &amp;objectId);
// コンテクストに対してオブジェクトを紐付け
glBindObject(GL_WINDOW_TARGET, objectId);
// 現在GL_WINDOW_TARGETに紐付いているオブジェクトのオプションを設定
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH,  800);
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);
// コンテクストの紐付けを初期状態に戻す
glBindObject(GL_WINDOW_TARGET, 0);。
</code></pre>

<p>
上のような記述はOpenGLで開発をしているとよくみかけます。まずオブジェクトを作成しそれを参照するためのIDを記憶しておきます（オブジェクトの実際のデータは開発者からは見えません）。つぎに記憶したIDによりオブジェクトをコンテクストのうち設定したいものに紐付けます（上の例では<var>GL_WINDOW_TARGET</var>と紐付けています）。そしてウィンドウのオプションを設定し、最後に<var>GL_WINDOW_TARGET</var>と紐付いたオブジェクトのIDを<code>0</code>にすることで、オブジェクトとコンテクストの紐付けを解除します。設定したオプションは<var>objectID</var>によって参照されるオブジェクトに保持され、オブジェクトを<var>GL_WINDOW_TARGET</var>と紐付けることでいつでも復元できます。
</p>

<warning>
ここまでのサンプルコードはOpenGLの操作をおおまかに記述したものです。以降では実際に動作するサンプルコードを多く提供します。
</warning>

<p>
オブジェクトを利用する利点は、複数のオブジェクトを定義、設定しておけば、OpenGLの状態を操作するときにそれらのオブジェクトのなかから用途にあわせたものを選べることです。例えば家やキャラクター等の3Dモデルのデータを保持した複数のオブジェクトを定義しておけば、各オブジェクトを紐付けるだけで、そのオブジェクトが保持している3Dモデルが描画できます（最初に各3Dモデルに対してオブジェクトを作成し、必要なオプションを設定すればいいのです）。こうすることでたくさんのモデルを描画するときにいちいちオプションを設定しなおさなくてすみます。
</p>

<h2>さあ、始めましょう</h2>
<p>
ここまでOpenGLについてざっくりと学びました。OpenGLが仕様であり、ライブラリであること。OpenGLの内部がどのように機能するのか、またOpenGLをどのように扱うのか。すべてを理解できなくても心配はいりません。この本では各段階においてOpenGLを理解するのに十分な例が提示されます。
</p>
  
<h2>参考</h2>
<ul>
  <li><a href="https://www.opengl.org/" target="_blank">opengl.org</a>: OpenGLの公式ウェブサイト。</li>
  <li><a href="https://www.opengl.org/registry/" target="_blank">OpenGL registry</a>: OpenGLのすべてのバージョンの仕様と拡張機能が確認できるサイト。</li>
</ul>
        

    </div>
</body>
</html>
