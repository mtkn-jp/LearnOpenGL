<!DOCTYPE html>
<html lang="ja"> 
<head>
    <meta charset="utf-8"/>
    <title>LearnOpenGL</title>
    <link rel="shortcut icon" type="image/ico" href="/favicon.ico"  />
	<link rel="stylesheet" href="../static/style.css" />
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script>
	<script src="/static/functions.js"></script>
</head>
<body>
	<nav>
<ol>
	<li id="Introduction">
		<a href="https://learnopengl.com/Introduction">はじめに</a>
	</li>
	<li id="Getting-started">
		<span class="closed">入門</span>
		<ol>
			<li id="Getting-started/OpenGL">
				<a href="https://learnopengl.com/Getting-started/OpenGL">OpenGL </a>
			</li>
			<li id="Getting-started/Creating-a-window">
				<a href="https://learnopengl.com/Getting-started/Creating-a-window">ウィンドウの作成</a>
			</li>
			<li id="Getting-started/Hello-Window">
				<a href="https://learnopengl.com/Getting-started/Hello-Window">最初のウィンドウ</a>
			</li>
			<li id="Getting-started/Hello-Triangle">
				<a href="https://learnopengl.com/Getting-started/Hello-Triangle">最初の三角形</a>
			</li>
			<li id="Getting-started/Shaders">
				<a href="https://learnopengl.com/Getting-started/Shaders">シェーダー</a>
			</li>
			<li id="Getting-started/Textures">
				<a href="https://learnopengl.com/Getting-started/Textures">テクスチャ</a>
			</li>
			<li id="Getting-started/Transformations">
				<a href="https://learnopengl.com/Getting-started/Transformations">座標変換</a>
			</li>
			<li id="Getting-started/Coordinate-Systems">
				<a href="https://learnopengl.com/Getting-started/Coordinate-Systems">座標系</a>
			</li>
			<li id="Getting-started/Camera">
				<a href="https://learnopengl.com/Getting-started/Camera">カメラ</a>
			</li>
			<li id="Getting-started/Review">
				<a href="https://learnopengl.com/Getting-started/Review">まとめ</a>
			</li>
		</ol>
	</li>
	<li id="Lighting">
		<span class="closed">Lighting </span>
		<ol>
			<li id="Lighting/Colors">
				<a href="https://learnopengl.com/Lighting/Colors">Colors </a>
			</li>
			<li id="Lighting/Basic-Lighting">
				<a href="https://learnopengl.com/Lighting/Basic-Lighting">Basic Lighting </a>
			</li>
			<li id="Lighting/Materials">
				<a href="https://learnopengl.com/Lighting/Materials">Materials </a>
			</li>
			<li id="Lighting/Lighting-maps">
				<a href="https://learnopengl.com/Lighting/Lighting-maps">Lighting maps </a>
			</li>
			<li id="Lighting/Light-casters">
				<a href="https://learnopengl.com/Lighting/Light-casters">Light casters </a>
			</li>
			<li id="Lighting/Multiple-lights">
				<a href="https://learnopengl.com/Lighting/Multiple-lights">Multiple lights </a>
			</li>
			<li id="Lighting/Review">
				<a href="https://learnopengl.com/Lighting/Review">Review </a>
			</li>
		</ol>
	</li>
	<li id="Model-Loading">
		<span class="closed">Model Loading </span>
		<ol>
			<li id="Model-Loading/Assimp">
				<a href="https://learnopengl.com/Model-Loading/Assimp">Assimp </a>
			</li>
			<li id="Model-Loading/Mesh">
				<a href="https://learnopengl.com/Model-Loading/Mesh">Mesh </a>
			</li>
			<li id="Model-Loading/Model">
				<a href="https://learnopengl.com/Model-Loading/Model">Model </a>
			</li>
		</ol>
	</li>
	<li id="Advanced-OpenGL">
		<span class="closed">Advanced OpenGL </span>
		<ol>
			<li id="Advanced-OpenGL/Depth-testing">
				<a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing">Depth testing </a>
			</li>
			<li id="Advanced-OpenGL/Stencil-testing">
				<a href="https://learnopengl.com/Advanced-OpenGL/Stencil-testing">Stencil testing </a>
			</li>
			<li id="Advanced-OpenGL/Blending">
				<a href="https://learnopengl.com/Advanced-OpenGL/Blending">Blending </a>
			</li>
			<li id="Advanced-OpenGL/Face-culling">
				<a href="https://learnopengl.cm/Advanced-OpenGL/Face-culling">Face culling </a>
			</li>
			<li id="Advanced-OpenGL/Framebuffers">
				<a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers">Framebuffers </a>
			</li>
			<li id="Advanced-OpenGL/Cubemaps">
				<a href="https://learnopengl.com/Advanced-OpenGL/Cubemaps">Cubemaps </a>
			</li>
			<li id="Advanced-OpenGL/Advanced-Data">
				<a href="https://learnopengl.com/Advanced-OpenGL/Advanced-Data">Advanced Data </a>
			</li>
			<li id="Advanced-OpenGL/Advanced-GLSL">
				<a href="https://learnopengl.com/Advanced-OpenGL/Advanced-GLSL">Advanced GLSL </a>
			</li>
			<li id="Advanced-OpenGL/Geometry-Shader">
				<a href="https://learnopengl.com/Advanced-OpenGL/Geometry-Shader">Geometry Shader </a>
			</li>
			<li id="Advanced-OpenGL/Instancing">
				<a href="https://learnopengl.com/Advanced-OpenGL/Instancing">Instancing </a>
			</li>
			<li id="Advanced-OpenGL/Anti-Aliasing">
				<a href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing">Anti Aliasing </a>
			</li>
		</ol>
	</li>
	<li id="Advanced-Lighting">
		<span class="closed">Advanced Lighting </span>
		<ol>
			<li id="Advanced-Lighting/Advanced-Lighting">
				<a href="https://learnopengl.com/Advanced-Lighting/Advanced-Lighting">Advanced Lighting </a>
			</li>
			<li id="Advanced-Lighting/Gamma-Correction">
				<a href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction">Gamma Correction </a>
			</li>
			<li id="Advanced-Lighting/Shadows">
				<span class="closed">Shadows </span>
				<ol>
					<li id="Advanced-Lighting/Shadows/Shadow-Mapping">
						<a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">Shadow Mapping </a>
					</li>
					<li id="Advanced-Lighting/Shadows/Point-Shadows">
						<a href="https://learnopengl.com/Advanced-Lighting/Shadows/Point-Shadows">Point Shadows </a>
					</li>
				</ol>
			</li>
			<li id="Advanced-Lighting/Normal-Mapping">
				<a href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping">Normal Mapping </a>
			</li>
			<li id="Advanced-Lighting/Parallax-Mapping">
				<a href="https://learnopengl.com/Advanced-Lighting/Parallax-Mapping">Parallax Mapping </a>
			</li>
			<li id="Advanced-Lighting/HDR">
				<a href="https://learnopengl.com/Advanced-Lighting/HDR">HDR </a>
			</li>
			<li id="Advanced-Lighting/Bloom">
				<a href="https://learnopengl.com/Advanced-Lighting/Bloom">Bloom </a>
			</li>
			<li id="Advanced-Lighting/Deferred-Shading">
				<a href="https://learnopengl.com/Advanced-Lighting/Deferred-Shading">Deferred Shading </a>
			</li>
			<li id="Advanced-Lighting/SSAO">
				<a href="https://learnopengl.com/Advanced-Lighting/SSAO">SSAO </a>
			</li>
		</ol>
	</li>
	<li id="PBR">
		<span class="closed">PBR </span>
		<ol>
			<li id="PBR/Theory">
				<a href="https://learnopengl.com/PBR/Theory">Theory </a>
			</li>
			<li id="PBR/Lighting">
				<a href="https://learnopengl.com/PBR/Lighting">Lighting </a>
			</li>
			<li id="PBR/IBL">
				<span class="closed">IBL </span>
				<ol>
					<li id="PBR/IBL/Diffuse-irradiance">
						<a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance">Diffuse irradiance </a>
					</li>
					<li id="PBR/IBL/Specular-IBL">
						<a href="https://learnopengl.com/PBR/IBL/Specular-IBL">Specular IBL </a>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li id="In-Practice">
		<span class="closed">In Practice </span>
		<ol>
			<li id="In-Practice/Debugging">
				<a href="https://learnopengl.com/In-Practice/Debugging">Debugging </a>
			</li>
			<li id="In-Practice/Text-Rendering">
				<a href="https://learnopengl.com/In-Practice/Text-Rendering">Text Rendering </a>
			</li>
			<li id="In-Practice/2D-Game">
				<span class="closed">2D Game </span>
				<ol>
					<li id="In-Practice/2D-Game/Breakout">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Breakout">Breakout </a>
					</li>
					<li id="In-Practice/2D-Game/Setting-up">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Setting-up">Setting up </a>
					</li>
					<li id="In-Practice/2D-Game/Rendering-Sprites">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Rendering-Sprites">Rendering Sprites </a>
					</li>
					<li id="In-Practice/2D-Game/Levels">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Levels">Levels </a>
					</li>
					<li id="In-Practice/2D-Game/Collisions">
						<span class="closed">Collisions </span>
						<ol>
							<li id="In-Practice/2D-Game/Collisions/Ball">
								<a href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Ball">Ball </a>
							</li>
							<li id="In-Practice/2D-Game/Collisions/Collision-detection">
								<a href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Collision-detection">Collision detection </a>
							</li>
							<li id="In-Practice/2D-Game/Collisions/Collision-resolution">
								<a href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Collision-resolution">Collision resolution </a>
							</li>
						</ol>
					</li>
					<li id="In-Practice/2D-Game/Particles">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Particles">Particles </a>
					</li>
					<li id="In-Practice/2D-Game/Postprocessing">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Postprocessing">Postprocessing </a>
					</li>
					<li id="In-Practice/2D-Game/Powerups">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Powerups">Powerups </a>
					</li>
					<li id="In-Practice/2D-Game/Audio">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Audio">Audio </a>
					</li>
					<li id="In-Practice/2D-Game/Render-text">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Render-text">Render text </a>
					</li>
					<li id="In-Practice/2D-Game/Final-thoughts">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Final-thoughts">Final thoughts </a>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li id="Guest-Articles">
		<span class="closed">Guest Articles </span>
		<ol>
			<li id="Guest-Articles/How-to-publish">
				<a href="https://learnopengl.com/Guest-Articles/How-to-publish">How to publish </a>
			</li>
			<li id="Guest-Articles/2020">
				<span class="closed">2020 </span>
				<ol>
					<li id="Guest-Articles/2020/OIT">
						<span class="closed">OIT </span>
						<ol>
							<li id="Guest-Articles/2020/OIT/Introduction">
								<a href="https://learnopengl.com/Guest-Articles/2020/OIT/Introduction">Introduction </a>
							</li>
							<li id="Guest-Articles/2020/OIT/Weighted-Blended">
								<a href="https://learnopengl.com/Guest-Articles/2020/OIT/Weighted-Blended">Weighted Blended </a>
							</li>
						</ol>
					</li>
					<li id="Guest-Articles/2020/Skeletal-Animation">
						<a href="https://learnopengl.com/Guest-Articles/2020/Skeletal-Animation">Skeletal Animation </a>
					</li>
				</ol>
			</li>
			<li id="Guest-Articles/2021">
				<span class="closed">2021 </span>
				<ol>
					<li id="Guest-Articles/2021/CSM">
						<a href="https://learnopengl.com/Guest-Articles/2021/CSM">CSM </a>
					</li>
					<li id="Guest-Articles/2021/Scene">
						<span class="closed">Scene </span>
						<ol>
							<li id="Guest-Articles/2021/Scene/Scene-Graph">
								<a href="https://learnopengl.com/Guest-Articles/2021/Scene/Scene-Graph">Scene Graph </a>
							</li>
							<li id="Guest-Articles/2021/Scene/Frustum-Culling">
								<a href="https://learnopengl.com/Guest-Articles/2021/Scene/Frustum-Culling">Frustum Culling </a>
							</li>
						</ol>
					</li>
					<li id="Guest-Articles/2021/Tessellation">
						<span class="closed">Tessellation </span>
						<ol>
							<li id="Guest-Articles/2021/Tessellation/Height-map">
								<a href="https://learnopengl.com/Guest-Articles/2021/Tessellation/Height-map">Height map </a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li id="Code-repository">
		<a href="https://learnopengl.com/Code-repository">Code repository </a>
	</li>
	<li id="Translations">
		<a href="https://learnopengl.com/Translations">Translations </a>
	</li>
	<li id="About">
		<a href="https://learnopengl.com/About">About </a>
	</li>
</ol>
	</nav>
	<main>
    <div id="content">
    <h1 id="content-title">Introduction</h1>
<h1 id="content-url" style='display:none;'>Guest-Articles/2020/OIT/Introduction</h1>
<p>
        In the <a href="https://learnopengl.com/Advanced-OpenGL/Blending" target="_blank">Blending</a> chapter, the subject of color blending was introduced. Blending is the way of implementing transparent surfaces in a 3D scene. In short, transparency delves into the subject of drawing semi-solid or fully see-through objects like glasses in computer graphics. The idea is explained up to a suitable point in that chapter, so if you're unfamiliar with the topic, better read Blending first.
    </p>

    <p>
        In this article, we are scratching the surface of this topic a bit further, since there are so many techniques involved in implementing such an effect in a 3D environment.
    </p>

    <p>
        To begin with, we are going to discuss about the limitations of the graphics library/hardware and the hardships they entail, and the reason that why transparency is such a tricky subject. Later on, we will introduce and briefly review some of the more well-known transparency techniques that have been invented and used for the past twenty years associated with the current hardware. Ultimately, we are going to focus on explaining and implementing one of them, which will be the subject of the following part of this article.
    </p>

    <p>
        Note that the goal of this article is to introduce techniques which have significantly better performance than the technique that was used in the Blending chapter. Otherwise, there isn't a genuinely compelling reason to expand on that matter.
    </p>

    <h2>Graphics library/hardware limitations</h2>

    <p>
        The reason that this article exists, and you're reading it, is that there is no direct way to draw transparent surfaces with the current technology. Many people wish, that it was as simple as turning on a flag in their graphics API, but that's a fairy tale. Whether, this is a limitation of the graphics libraries or video cards, that's debatable.
    </p>

    <p>
        As explained in the Blending chapter, the source of this problem arises from combining depth testing and color blending. At the fragment stage, there is no buffer like the depth buffer for transparent pixels that would tell the graphics library, which pixels are fully visible or semi-visible. One of the reasons could be, that there is no efficient way of storing the information of transparent pixels in such a buffer that can hold an infinite number of pixels for each coordinate on the screen. Since each transparent pixel could expose its underlying pixels, therefore there needs to be a way to store different layers of all pixels for all screen coordinates.
    </p>

    <p>
        This limitation leaves us to think for a way to overcome such an issue and since neither the graphics library nor the hardware gives us a hand, this all has to be done by the developer with the tools at hand. We will examine two methods which are prominent in this subject. One being, <def>ordered transparency</def> and the other <def>order-independent transparency</def>.
    </p>

    <h2>Ordered transparency</h2>

    <p>
         The most convenient solution to overcome this issue, is to sort your transparent objects, so they're either drawn from the furthest to the nearest, or from the nearest to the furthest in relation to the camera's position. This way, the depth testing wouldn't affect the outcome of those pixels that have been drawn after/before but over/under a further/closer object. However major the expenditure this method entails for the CPU, it was used in many early games that probably most of us have played.
    </p>

    <p>
        For example, the sample image below shows the importance of blending order. The top part of the image produces an incorrect result with unordered alpha blending, while the bottom correctly sorts the geometry. Note lower visibility of the skeletal structure without correct depth ordering.
        This image is from <a href="http://gpuopen.com/archive/gpu-demos/radeon-hd-5000-series-graphics-real-time-demos/" target="_blank">ATI Mecha Demo</a>:
    </p>

<img src="/img/guest/2020/oit/ATI_Mecha_Demo_Screenshot.jpg" width="287" alt="Importance of ordering from ATI Mecha Demo">

    <p>
        So far, we have understood that in order to overcome the limitation of current technology to draw transparent objects, we need order for our transparent objects to be displayed properly on the screen. Ordering takes away performance from your application, and since most of 3D applications are running in real-time, this will be so much more evident as you perform sorting at every frame.
    </p>

    <p>
        Therefore, we will be looking into the world of order-independent transparency techniques and to find one which better suits our purpose and furthermore our pipeline, so we don't have to sort the objects before drawing.
    </p>

    <h2>Order-independent transparency</h2>

    <p>
        Order-independent transparency or for short <def>OIT</def>, is a technique which doesn't require us to draw our transparent objects in an orderly fashion. At first glance, this will give us back the CPU cycles that we were taking for sorting the objects, but at the same time OIT techniques have their pros and cons.
    </p>

    <p>
        The goal of OIT techniques is to eliminate the need of sorting transparent objects at draw time. Depending on the technique, some of them must sort fragments for an accurate result, but only at a later stage when all the draw calls have been made, and some of them don't require sorting, but results are approximated.
    </p>

    <h3>History</h3>

    <p>
        Some of the more advanced techniques that have been invented to overcome the limitation of rendering transparent surfaces, explicitly use a buffer (e.g. a linked list or a 3D array such as [x][y][z]) that can hold multiple layers of pixels' information and can sort pixels on the GPU, normally because of its parallel processing power, as opposed to CPU.
    </p>

    <note>
        The <a href="https://en.wikipedia.org/wiki/A-buffer" target="_blank">A-buffer</a> is a computer graphics technique introduced in 1984 which stores per-pixel lists of fragment data (including <a href="https://en.wikipedia.org/wiki/Micropolygon" target="_blank">micro-polygon</a> information) in a software rasterizer, <a href="https://en.wikipedia.org/wiki/Reyes_rendering" target="_blank">REYES</a>, originally designed for anti-aliasing but also supporting transparency. 
    </note>

    <p>
        At the same time, there has been hardware capable of facilitating this task by performing on-hardware calculations which is the most convenient way for a developer to have access to transparency out of the box.
    </p>

    <note>
        <a href="https://en.wikipedia.org/wiki/Dreamcast#Hardware" target="_blank">SEGA Dreamcast</a> was one of the few consoles that had automatic per-pixel translucency sorting, implemented in its hardware.
    </note>

    <p>
        Commonly, OIT techniques are separated into two categories which are <def>exact</def> and <def>approximate</def>. Respectively, exact will result in better images with an accurate transparency which suits every scenario, while approximate although resulting in good-looking images, lacks accuracy in complex scenes.
    </p>

    <h3>Exact OIT</h3>

    <p>
        These techniques accurately compute the final color, for which all fragments must be sorted. For high depth complexity scenes, sorting becomes the bottleneck.
    </p>

    <p>
        One issue with the sorting stage is <def>local memory limited occupancy</def>, in this case a <a href="https://en.wikipedia.org/wiki/Single_Instruction_Multiple_Threads" target="_blank">single instruction, multiple threads</a> attribute relating to the throughput and operation latency hiding of GPUs. 
        Although, <a href="http://diglib.eg.org/handle/10.2312/PE.PG.PG2013short.059-064" target="_blank">BMA</a> (backwards memory allocation) can group pixels by their depth complexity and sort them in batches to improve the occupancy and hence performance of low depth complexity pixels in the context of a potentially high depth complexity scene. Up to a 3× overall OIT performance increase is reported.
    </p>

    <note>
        The sorting stage requires relatively large amounts of temporary memory in shaders that is usually conservatively allocated at a maximum, which impacts memory occupancy and performance.
    </note>

    <p>
        Sorting is typically performed in a local array, however performance can be improved further by making use of the GPU's memory hierarchy and sorting in registers, similarly to an <a href="https://en.wikipedia.org/wiki/External_sorting#External_merge_sort" target="_blank">external merge sort</a>, especially in conjunction with BMA.
    </p>

    <h3>Approximate OIT</h3>

    <p>
        Approximate OIT techniques relax the constraint of exact rendering to provide faster results. Higher performance can be gained from not having to store all fragments or only partially sorting the geometry. A number of techniques also compress, or reduce, the fragment data. These include:
    </p>

    <ul>
        <li>Stochastic Transparency: draw in a higher resolution in full opacity but discard some fragments. Down-sampling will then yield transparency.</li>
        <li>Adaptive Transparency: a two-pass technique where the first constructs a visibility function which compresses on the fly (this compression avoids having to fully sort the fragments) and the second uses this data to composite unordered fragments. Intel's pixel synchronization avoids the need to store all fragments, removing the unbounded memory requirement of many other OIT techniques.</li>
    </ul>

    <h3>Techniques</h3>

    <p>
        Some of the OIT techniques that have been commonly used in the industry are as follows:
    </p>

    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Depth_peeling" target="_blank">Depth peeling</a>: Introduced in 2001, described a hardware accelerated OIT technique which utilizes the depth buffer to peel a layer of pixels at each pass. With limitations in graphics hardware the scene's geometry had to be rendered many times.</li>
        <li><a href="http://developer.download.nvidia.com/SDK/10/opengl/src/dual_depth_peeling/doc/DualDepthPeeling.pdf" target="_blank">Dual depth peeling</a>: Introduced in 2008, improves on the performance of depth peeling, still with many-pass rendering limitation.</li>
        <li><a href="http://jcgt.org/published/0002/02/09/" target="_blank">Weighted, blended</a>: Published in 2013, utilizes a weighting function and two buffers for pixel color and pixel reveal threshold for the final composition pass. Results in an approximated image with a decent quality in complex scenes.</li>
    </ul>

    <h2>Implementation</h2>

    <p>
        The usual way of performing OIT in 3D applications is to do it in multiple passes. There are at least three passes required for an OIT technique to be performed, so in order to do this, you'll have to have a perfect understanding of how <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers" target="_blank">Framebuffers</a> work in OpenGL. Once you're comfortable with Framebuffers, it all boils down to the implementation complexity of the technique you are trying to implement.
    </p>

    <p>
        Briefly explained, the three passes involved are as follows:
    </p>

    <ol>
        <li>First pass, is where you draw all of your solid objects, this means any object that does not let the light travel through its geometry.</li>
        <li>Second pass, is where you draw all of your translucent objects. Objects that need alpha discarding, can be rendered in the first pass.</li>
        <li>Third pass, is where you composite the images that resulted from two previous passes and draw that image onto your backbuffer.</li>
    </ol>

    <p>
        This routine is almost identical in implementing OIT techniques across all different pipelines.
    </p>

    <p>
        In the next part of this article, we are going to implement weighted, blended OIT which is one of the easiest and high performance OIT techniques that has been used in the video game industry for the past ten years.
    </p>

    <h2>Further reading</h2>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Dreamcast#Hardware" target="_blank">SEGA Dreamcast Hardware</a>: Dreamcast was one of the few consoles that had hardware implemented order-independent transparency.</li>
        <li><a href="https://en.wikipedia.org/wiki/Order-independent_transparency" target="_blank">Order-independent transparency</a>: A series of techniques that have a great performance and produce nice results even with the approximated methods.</li>
        <li><a href="http://casual-effects.blogspot.com/2014/03/weighted-blended-order-independent.html" target="_blank">Weighted, blended order-independent transparency</a>: One of the easiest OIT techniques in terms of implementation while producing highly acceptable images for complex scenes.</li>
    </ul>
  
<author>
  <strong>Article by: </strong>Mahan Heshmati Moghaddam<br/>
  <strong>Contact: </strong><a href="mailto:mahangm@gmail.com" target="_blank">e-mail</a>
</author>       

    </div>
    
	</main>
</body>
</html>
