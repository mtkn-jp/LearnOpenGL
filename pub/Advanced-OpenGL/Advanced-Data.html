<!DOCTYPE html>
<html lang="ja"> 
<head>
    <meta charset="utf-8"/>
    <title>LearnOpenGL</title>
    <link rel="shortcut icon" type="image/ico" href="/favicon.ico"  />
	<link rel="stylesheet" href="../static/style.css" />
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script>
	<script src="/static/functions.js"></script>
</head>
<body>
	<nav>
<ol>
	<li id="Introduction">
		<a href="https://learnopengl.com/Introduction">はじめに</a>
	</li>
	<li id="Getting-started">
		<span class="closed">入門</span>
		<ol>
			<li id="Getting-started/OpenGL">
				<a href="https://learnopengl.com/Getting-started/OpenGL">OpenGL </a>
			</li>
			<li id="Getting-started/Creating-a-window">
				<a href="https://learnopengl.com/Getting-started/Creating-a-window">ウィンドウの作成</a>
			</li>
			<li id="Getting-started/Hello-Window">
				<a href="https://learnopengl.com/Getting-started/Hello-Window">最初のウィンドウ</a>
			</li>
			<li id="Getting-started/Hello-Triangle">
				<a href="https://learnopengl.com/Getting-started/Hello-Triangle">最初の三角形</a>
			</li>
			<li id="Getting-started/Shaders">
				<a href="https://learnopengl.com/Getting-started/Shaders">シェーダー</a>
			</li>
			<li id="Getting-started/Textures">
				<a href="https://learnopengl.com/Getting-started/Textures">テクスチャ</a>
			</li>
			<li id="Getting-started/Transformations">
				<a href="https://learnopengl.com/Getting-started/Transformations">座標変換</a>
			</li>
			<li id="Getting-started/Coordinate-Systems">
				<a href="https://learnopengl.com/Getting-started/Coordinate-Systems">座標系</a>
			</li>
			<li id="Getting-started/Camera">
				<a href="https://learnopengl.com/Getting-started/Camera">カメラ</a>
			</li>
			<li id="Getting-started/Review">
				<a href="https://learnopengl.com/Getting-started/Review">まとめ</a>
			</li>
		</ol>
	</li>
	<li id="Lighting">
		<span class="closed">Lighting </span>
		<ol>
			<li id="Lighting/Colors">
				<a href="https://learnopengl.com/Lighting/Colors">Colors </a>
			</li>
			<li id="Lighting/Basic-Lighting">
				<a href="https://learnopengl.com/Lighting/Basic-Lighting">Basic Lighting </a>
			</li>
			<li id="Lighting/Materials">
				<a href="https://learnopengl.com/Lighting/Materials">Materials </a>
			</li>
			<li id="Lighting/Lighting-maps">
				<a href="https://learnopengl.com/Lighting/Lighting-maps">Lighting maps </a>
			</li>
			<li id="Lighting/Light-casters">
				<a href="https://learnopengl.com/Lighting/Light-casters">Light casters </a>
			</li>
			<li id="Lighting/Multiple-lights">
				<a href="https://learnopengl.com/Lighting/Multiple-lights">Multiple lights </a>
			</li>
			<li id="Lighting/Review">
				<a href="https://learnopengl.com/Lighting/Review">Review </a>
			</li>
		</ol>
	</li>
	<li id="Model-Loading">
		<span class="closed">Model Loading </span>
		<ol>
			<li id="Model-Loading/Assimp">
				<a href="https://learnopengl.com/Model-Loading/Assimp">Assimp </a>
			</li>
			<li id="Model-Loading/Mesh">
				<a href="https://learnopengl.com/Model-Loading/Mesh">Mesh </a>
			</li>
			<li id="Model-Loading/Model">
				<a href="https://learnopengl.com/Model-Loading/Model">Model </a>
			</li>
		</ol>
	</li>
	<li id="Advanced-OpenGL">
		<span class="closed">Advanced OpenGL </span>
		<ol>
			<li id="Advanced-OpenGL/Depth-testing">
				<a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing">Depth testing </a>
			</li>
			<li id="Advanced-OpenGL/Stencil-testing">
				<a href="https://learnopengl.com/Advanced-OpenGL/Stencil-testing">Stencil testing </a>
			</li>
			<li id="Advanced-OpenGL/Blending">
				<a href="https://learnopengl.com/Advanced-OpenGL/Blending">Blending </a>
			</li>
			<li id="Advanced-OpenGL/Face-culling">
				<a href="https://learnopengl.cm/Advanced-OpenGL/Face-culling">Face culling </a>
			</li>
			<li id="Advanced-OpenGL/Framebuffers">
				<a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers">Framebuffers </a>
			</li>
			<li id="Advanced-OpenGL/Cubemaps">
				<a href="https://learnopengl.com/Advanced-OpenGL/Cubemaps">Cubemaps </a>
			</li>
			<li id="Advanced-OpenGL/Advanced-Data">
				<a href="https://learnopengl.com/Advanced-OpenGL/Advanced-Data">Advanced Data </a>
			</li>
			<li id="Advanced-OpenGL/Advanced-GLSL">
				<a href="https://learnopengl.com/Advanced-OpenGL/Advanced-GLSL">Advanced GLSL </a>
			</li>
			<li id="Advanced-OpenGL/Geometry-Shader">
				<a href="https://learnopengl.com/Advanced-OpenGL/Geometry-Shader">Geometry Shader </a>
			</li>
			<li id="Advanced-OpenGL/Instancing">
				<a href="https://learnopengl.com/Advanced-OpenGL/Instancing">Instancing </a>
			</li>
			<li id="Advanced-OpenGL/Anti-Aliasing">
				<a href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing">Anti Aliasing </a>
			</li>
		</ol>
	</li>
	<li id="Advanced-Lighting">
		<span class="closed">Advanced Lighting </span>
		<ol>
			<li id="Advanced-Lighting/Advanced-Lighting">
				<a href="https://learnopengl.com/Advanced-Lighting/Advanced-Lighting">Advanced Lighting </a>
			</li>
			<li id="Advanced-Lighting/Gamma-Correction">
				<a href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction">Gamma Correction </a>
			</li>
			<li id="Advanced-Lighting/Shadows">
				<span class="closed">Shadows </span>
				<ol>
					<li id="Advanced-Lighting/Shadows/Shadow-Mapping">
						<a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">Shadow Mapping </a>
					</li>
					<li id="Advanced-Lighting/Shadows/Point-Shadows">
						<a href="https://learnopengl.com/Advanced-Lighting/Shadows/Point-Shadows">Point Shadows </a>
					</li>
				</ol>
			</li>
			<li id="Advanced-Lighting/Normal-Mapping">
				<a href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping">Normal Mapping </a>
			</li>
			<li id="Advanced-Lighting/Parallax-Mapping">
				<a href="https://learnopengl.com/Advanced-Lighting/Parallax-Mapping">Parallax Mapping </a>
			</li>
			<li id="Advanced-Lighting/HDR">
				<a href="https://learnopengl.com/Advanced-Lighting/HDR">HDR </a>
			</li>
			<li id="Advanced-Lighting/Bloom">
				<a href="https://learnopengl.com/Advanced-Lighting/Bloom">Bloom </a>
			</li>
			<li id="Advanced-Lighting/Deferred-Shading">
				<a href="https://learnopengl.com/Advanced-Lighting/Deferred-Shading">Deferred Shading </a>
			</li>
			<li id="Advanced-Lighting/SSAO">
				<a href="https://learnopengl.com/Advanced-Lighting/SSAO">SSAO </a>
			</li>
		</ol>
	</li>
	<li id="PBR">
		<span class="closed">PBR </span>
		<ol>
			<li id="PBR/Theory">
				<a href="https://learnopengl.com/PBR/Theory">Theory </a>
			</li>
			<li id="PBR/Lighting">
				<a href="https://learnopengl.com/PBR/Lighting">Lighting </a>
			</li>
			<li id="PBR/IBL">
				<span class="closed">IBL </span>
				<ol>
					<li id="PBR/IBL/Diffuse-irradiance">
						<a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance">Diffuse irradiance </a>
					</li>
					<li id="PBR/IBL/Specular-IBL">
						<a href="https://learnopengl.com/PBR/IBL/Specular-IBL">Specular IBL </a>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li id="In-Practice">
		<span class="closed">In Practice </span>
		<ol>
			<li id="In-Practice/Debugging">
				<a href="https://learnopengl.com/In-Practice/Debugging">Debugging </a>
			</li>
			<li id="In-Practice/Text-Rendering">
				<a href="https://learnopengl.com/In-Practice/Text-Rendering">Text Rendering </a>
			</li>
			<li id="In-Practice/2D-Game">
				<span class="closed">2D Game </span>
				<ol>
					<li id="In-Practice/2D-Game/Breakout">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Breakout">Breakout </a>
					</li>
					<li id="In-Practice/2D-Game/Setting-up">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Setting-up">Setting up </a>
					</li>
					<li id="In-Practice/2D-Game/Rendering-Sprites">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Rendering-Sprites">Rendering Sprites </a>
					</li>
					<li id="In-Practice/2D-Game/Levels">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Levels">Levels </a>
					</li>
					<li id="In-Practice/2D-Game/Collisions">
						<span class="closed">Collisions </span>
						<ol>
							<li id="In-Practice/2D-Game/Collisions/Ball">
								<a href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Ball">Ball </a>
							</li>
							<li id="In-Practice/2D-Game/Collisions/Collision-detection">
								<a href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Collision-detection">Collision detection </a>
							</li>
							<li id="In-Practice/2D-Game/Collisions/Collision-resolution">
								<a href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Collision-resolution">Collision resolution </a>
							</li>
						</ol>
					</li>
					<li id="In-Practice/2D-Game/Particles">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Particles">Particles </a>
					</li>
					<li id="In-Practice/2D-Game/Postprocessing">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Postprocessing">Postprocessing </a>
					</li>
					<li id="In-Practice/2D-Game/Powerups">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Powerups">Powerups </a>
					</li>
					<li id="In-Practice/2D-Game/Audio">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Audio">Audio </a>
					</li>
					<li id="In-Practice/2D-Game/Render-text">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Render-text">Render text </a>
					</li>
					<li id="In-Practice/2D-Game/Final-thoughts">
						<a href="https://learnopengl.com/In-Practice/2D-Game/Final-thoughts">Final thoughts </a>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li id="Guest-Articles">
		<span class="closed">Guest Articles </span>
		<ol>
			<li id="Guest-Articles/How-to-publish">
				<a href="https://learnopengl.com/Guest-Articles/How-to-publish">How to publish </a>
			</li>
			<li id="Guest-Articles/2020">
				<span class="closed">2020 </span>
				<ol>
					<li id="Guest-Articles/2020/OIT">
						<span class="closed">OIT </span>
						<ol>
							<li id="Guest-Articles/2020/OIT/Introduction">
								<a href="https://learnopengl.com/Guest-Articles/2020/OIT/Introduction">Introduction </a>
							</li>
							<li id="Guest-Articles/2020/OIT/Weighted-Blended">
								<a href="https://learnopengl.com/Guest-Articles/2020/OIT/Weighted-Blended">Weighted Blended </a>
							</li>
						</ol>
					</li>
					<li id="Guest-Articles/2020/Skeletal-Animation">
						<a href="https://learnopengl.com/Guest-Articles/2020/Skeletal-Animation">Skeletal Animation </a>
					</li>
				</ol>
			</li>
			<li id="Guest-Articles/2021">
				<span class="closed">2021 </span>
				<ol>
					<li id="Guest-Articles/2021/CSM">
						<a href="https://learnopengl.com/Guest-Articles/2021/CSM">CSM </a>
					</li>
					<li id="Guest-Articles/2021/Scene">
						<span class="closed">Scene </span>
						<ol>
							<li id="Guest-Articles/2021/Scene/Scene-Graph">
								<a href="https://learnopengl.com/Guest-Articles/2021/Scene/Scene-Graph">Scene Graph </a>
							</li>
							<li id="Guest-Articles/2021/Scene/Frustum-Culling">
								<a href="https://learnopengl.com/Guest-Articles/2021/Scene/Frustum-Culling">Frustum Culling </a>
							</li>
						</ol>
					</li>
					<li id="Guest-Articles/2021/Tessellation">
						<span class="closed">Tessellation </span>
						<ol>
							<li id="Guest-Articles/2021/Tessellation/Height-map">
								<a href="https://learnopengl.com/Guest-Articles/2021/Tessellation/Height-map">Height map </a>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li id="Code-repository">
		<a href="https://learnopengl.com/Code-repository">Code repository </a>
	</li>
	<li id="Translations">
		<a href="https://learnopengl.com/Translations">Translations </a>
	</li>
	<li id="About">
		<a href="https://learnopengl.com/About">About </a>
	</li>
</ol>
	</nav>
	<main>
    <div id="content">
    <h1 id="content-title">Advanced Data</h1>
<h1 id="content-url" style='display:none;'>Advanced-OpenGL/Advanced-Data</h1>
<p>
  Throughout most chapters we've been extensively using buffers in OpenGL to store data on the GPU. This chapter we'll briefly discuss a few alternative approaches to managing buffers.
</p>

<p>
  A buffer in OpenGL is, at its core, an object that manages a certain piece of GPU memory and nothing more. We give meaning to a buffer when binding it to a specific <def>buffer target</def>. A buffer is only a vertex array buffer when we bind it to <var>GL_ARRAY_BUFFER</var>, but we could just as easily bind it to <var>GL_ELEMENT_ARRAY_BUFFER</var>. OpenGL internally stores a reference to the buffer per target and, based on the target, processes the buffer differently. 
</p>

<p>
  So far we've been filling the buffer's memory by calling <fun><function id='31'>glBufferData</function></fun>, which allocates a piece of GPU memory and adds data into this memory. If we were to pass <code>NULL</code> as its data argument, the function would only allocate memory and not fill it. This is useful if we first want to <em>reserve</em> a specific amount of memory and later come back to this buffer.
</p>

<p>
  Instead of filling the entire buffer with one function call we can also fill specific regions of the buffer by calling <fun><function id='90'>glBufferSubData</function></fun>. This function expects a buffer target, an offset, the size of the data and the actual data as its arguments. What's new with this function is that we can now give an offset that specifies from <em>where</em> we want to fill the buffer. This allows us to insert/update only certain parts of the buffer's memory. Do note that the buffer should have enough allocated memory so a call to <fun><function id='31'>glBufferData</function></fun> is necessary before calling <fun><function id='90'>glBufferSubData</function></fun> on the buffer.
</p>

<pre><code>
<function id='90'>glBufferSubData</function>(GL_ARRAY_BUFFER, 24, sizeof(data), &data); // Range: [24, 24 + sizeof(data)]
</code></pre>

<p>
  Yet another method for getting data into a buffer is to ask for a pointer to the buffer's memory and directly copy the data in memory yourself. By calling <fun><function id='91'>glMapBuffer</function></fun> OpenGL returns a pointer to the currently bound buffer's memory for us to operate on:
</p>

<pre><code>
float data[] = {
  0.5f, 1.0f, -0.35f
  [...]
};
<function id='32'>glBindBuffer</function>(GL_ARRAY_BUFFER, buffer);
// get pointer
void *ptr = <function id='91'>glMapBuffer</function>(GL_ARRAY_BUFFER, GL_WRITE_ONLY);
// now copy data into memory
memcpy(ptr, data, sizeof(data));
// make sure to tell OpenGL we're done with the pointer
<function id='92'>glUnmapBuffer</function>(GL_ARRAY_BUFFER);
</code></pre>

<p>
  By telling OpenGL we're finished with the pointer operations via <fun><function id='92'>glUnmapBuffer</function></fun>, OpenGL knows you're done. By unmapping, the pointer becomes invalid and the function returns <var>GL_TRUE</var> if OpenGL was able to map your data successfully to the buffer.
</p>

<p>
  Using <fun><function id='91'>glMapBuffer</function></fun> is useful for directly mapping data to a buffer, without first storing it in temporary memory. Think of directly reading data from file and copying it into the buffer's memory.
</p>

<h2>Batching vertex attributes</h2>
<p>
  Using <fun><function id='30'>glVertexAttribPointer</function></fun> we were able to specify the attribute layout of the vertex array buffer's content. Within the vertex array buffer we <def>interleaved</def> the attributes; that is, we placed the position, normal and/or texture coordinates next to each other in memory for each vertex. Now that we know a bit more about buffers we can take a different approach.
</p>
  
<p>
  What we could also do is batch all the vector data into large chunks per attribute type instead of interleaving them. Instead of an interleaved layout <code>123123123123</code> we take a batched approach <code>111122223333</code>. 
</p>

<p>
  When loading vertex data from file you generally retrieve an array of positions, an array of normals and/or an array of texture coordinates. It may cost some effort to combine these arrays into one large array of interleaved data. Taking the batching approach is then an easier solution that we can easily implement using <fun><function id='90'>glBufferSubData</function></fun>:
</p>

<pre><code>
float positions[] = { ... };
float normals[] = { ... };
float tex[] = { ... };
// fill buffer
<function id='90'>glBufferSubData</function>(GL_ARRAY_BUFFER, 0, sizeof(positions), &positions);
<function id='90'>glBufferSubData</function>(GL_ARRAY_BUFFER, sizeof(positions), sizeof(normals), &normals);
<function id='90'>glBufferSubData</function>(GL_ARRAY_BUFFER, sizeof(positions) + sizeof(normals), sizeof(tex), &tex);
</code></pre>

<p>
  This way we can directly transfer the attribute arrays as a whole into the buffer without first having to process them. We could have also combined them in one large array and fill the buffer right away using <fun><function id='31'>glBufferData</function></fun>, but using <fun><function id='90'>glBufferSubData</function></fun> lends itself perfectly for tasks like these.
</p>
<p>
  We'll also have to update the vertex attribute pointers to reflect these changes:
</p>

<pre><code>
<function id='30'>glVertexAttribPointer</function>(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0);  
<function id='30'>glVertexAttribPointer</function>(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)(sizeof(positions)));  
<function id='30'>glVertexAttribPointer</function>(
  2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)(sizeof(positions) + sizeof(normals)));  
</code></pre>

<p>
  Note that the <code>stride</code> parameter is equal to the size of the vertex attribute, since the next vertex attribute vector can be found directly after its 3 (or 2) components. 
</p>

<p>
  This gives us yet another approach of setting and specifying vertex attributes. Using either approach is feasible, it is mostly a more organized way to set vertex attributes. However, the interleaved approach is still the recommended approach as the vertex attributes for each vertex shader run are then closely aligned in memory. 
</p>

<h2>Copying buffers</h2>
<p>
  Once your buffers are filled with data you may want to share that data with other buffers or perhaps copy the buffer's content into another buffer. The function <fun><function id='93'>glCopyBufferSubData</function></fun> allows us to copy the data from one buffer to another buffer with relative ease. The function's prototype is as follows:
</p>

<pre><code>
void <function id='93'>glCopyBufferSubData</function>(GLenum readtarget, GLenum writetarget, GLintptr readoffset,
                         GLintptr writeoffset, GLsizeiptr size);
</code></pre>

<p>
  The <code>readtarget</code> and <code>writetarget</code> parameters expect to give the buffer targets that we want to copy from and to. We could for example copy from a  <var>VERTEX_ARRAY_BUFFER</var> buffer to a <var>VERTEX_ELEMENT_ARRAY_BUFFER</var> buffer by specifying those buffer targets as the read and write targets respectively. The buffers currently bound to those buffer targets will then be affected. 
</p>

<p>
  But what if we wanted to read and write data into two different buffers that are both vertex array buffers? We can't bind two buffers at the same time to the same buffer target. For this reason, and this reason alone, OpenGL gives us two more buffer targets called <var>GL_COPY_READ_BUFFER</var> and <var>GL_COPY_WRITE_BUFFER</var>. We then bind the buffers of our choice to these new buffer targets and set those targets as the <code>readtarget</code> and <code>writetarget</code> argument.
</p>

<p>
  <fun><function id='93'>glCopyBufferSubData</function></fun> then reads data of a given <code>size</code> from a given <code>readoffset</code> and writes it into the <code>writetarget</code> buffer at <code>writeoffset</code>. An example of copying the content of two vertex array buffers is shown below:
</p>

<pre><code>
<function id='32'>glBindBuffer</function>(GL_COPY_READ_BUFFER, vbo1);
<function id='32'>glBindBuffer</function>(GL_COPY_WRITE_BUFFER, vbo2);
<function id='93'>glCopyBufferSubData</function>(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, 8 * sizeof(float));
</code></pre>

<p>
  We could've also done this by only binding the <code>writetarget</code> buffer to one of the new buffer target types:
</p>

<pre><code>
float vertexData[] = { ... };
<function id='32'>glBindBuffer</function>(GL_ARRAY_BUFFER, vbo1);
<function id='32'>glBindBuffer</function>(GL_COPY_WRITE_BUFFER, vbo2);
<function id='93'>glCopyBufferSubData</function>(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, 8 * sizeof(float));  
</code></pre>


<p>
  With some extra knowledge about how to manipulate buffers we can already use them in more interesting ways. The further you get in OpenGL, the more useful these new buffer methods start to become. In the <a href="https://learnopengl.com/Advanced-OpenGL/Advanced-GLSL" target="_blank">next</a> chapter, where we'll discuss <def>uniform buffer objects</def>, we'll make good use of <fun><function id='90'>glBufferSubData</function></fun>.
</p>       

    </div>
    
	</main>
</body>
</html>
